<!doctype html><html dir=ltr lang=en data-theme class=html><head><title>Geektree0101
|
ASCollectionNode 다루기 #1</title><meta charset=utf-8><meta name=generator content="Hugo 0.107.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="Geektree0101"><meta name=description content="UICollectionView만 있으면 세상에 현존하는 어떠한 형태의  화면이든 자유롭게 그려낼 수 있는 아주 멋진 View에요! :]"><link rel=stylesheet href=/scss/main.min.b2e0cb07595e3519ab1193bb421914e06c0e26b0cc561fef23b3c6131d4d2ffa.css integrity="sha256-suDLB1leNRmrEZO7QhkU4GwOJrDMVh/vI7PGEx1NL/o=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.b1c4e6a10bdbab01f33fff9d78816ee68cf9a9a731f07668afd546a79924cb80.css integrity="sha256-scTmoQvbqwHzP/+deIFu5oz5qacx8HZor9VGp5kky4A=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.423dee17c62f55fa733a4ee13e00d523dfce88cc4f4ab4549a24ba36bd9de681.css integrity="sha256-Qj3uF8YvVfpzOk7hPgDVI9/OiMxPSrRUmiS6Nr2d5oE=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.b7d54133b27e5b4de15245b8e143de3e8ed2d674c706137274cedc9953f31917.css integrity="sha256-t9VBM7J+W03hUkW44UPePo7S1nTHBhNydM7cmVPzGRc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=https://geektree0101.github.io/blog/blog11/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.738c0e3a493854876aeab9e2316fd43f1936aeeac4cc6b3e60bb26456dba72ad.js integrity="sha256-c4wOOkk4VIdq6rniMW/UPxk2rurEzGs+YLsmRW26cq0=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="ASCollectionNode 다루기 #1"><meta name=twitter:description content="UICollectionView만 있으면 세상에 현존하는 어떠한 형태의  화면이든 자유롭게 그려낼 수 있는 아주 멋진 View에요! :]"><meta property="og:title" content="ASCollectionNode 다루기 #1"><meta property="og:description" content="UICollectionView만 있으면 세상에 현존하는 어떠한 형태의  화면이든 자유롭게 그려낼 수 있는 아주 멋진 View에요! :]"><meta property="og:type" content="article"><meta property="og:url" content="https://geektree0101.github.io/blog/blog11/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2020-01-31T12:41:56+00:00"><meta property="article:modified_time" content="2020-01-31T12:41:56+00:00"><meta property="og:site_name" content="Hyeonsu Ha"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"blog","name":"ASCollectionNode 다루기 #1","headline":"ASCollectionNode 다루기 #1","alternativeHeadline":"","description":"
      UICollectionView만 있으면 세상에 현존하는 어떠한 형태의  화면이든 자유롭게 그려낼 수 있는 아주 멋진 View에요! :]


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/geektree0101.github.io\/blog\/blog11\/"},"author":{"@type":"Person","name":"Geektree0101"},"creator":{"@type":"Person","name":"Geektree0101"},"accountablePerson":{"@type":"Person","name":"Geektree0101"},"copyrightHolder":{"@type":"Person","name":"Geektree0101"},"copyrightYear":"2020","dateCreated":"2020-01-31T12:41:56.34Z","datePublished":"2020-01-31T12:41:56.34Z","dateModified":"2020-01-31T12:41:56.34Z","publisher":{"@type":"Organization","name":"Geektree0101","url":"https://geektree0101.github.io/","logo":{"@type":"ImageObject","url":"https:\/\/geektree0101.github.io\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/geektree0101.github.io\/blog\/blog11\/","wordCount":"523","genre":["iOS"],"keywords":["ios","texture"]}</script></head><body class="body theme--light"><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src="https://avatars.githubusercontent.com/u/19504988?v=4" alt="profile picture"><div class=sidebar__introduction-title><a href=/>Hyeonsu Ha</a></div><div class=sidebar__introduction-description><p>저는 Product Engineer이자 iOS App을 개발하고 있어요<br>제품설계, 가치전달, 협업문화에 대해 많은 관심을 가지고있어요.<br><br>I'm a Product Engineer & iOS software engineer.<br>I'm interested in product structure design, product value communication, and collaboration culture.<br><br>我是Product Engineer和iOS软件工程师。<br>我对产品结构设计、产品价值沟通、合作文化感兴趣。<br></p></div></div><ul class=sidebar__list><li class=sidebar__list-item><a href=https://www.linkedin.com/in/hyeonsu-ha-7ba02b112/ target=_blank rel=noopener aria-label=Linkedin title=Linkedin><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=h2s1880@gmail.com target=_blank rel=noopener aria-label=e-mail title=e-mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://github.com/GeekTree0101 target=_blank rel=noopener aria-label=github title=github><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://www.instagram.com/geektree0101/ target=_blank rel=noopener aria-label=instagram title=instagram><i class="fab fa-instagram fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
Geektree0101
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/ title>Index 0</a></li><li class=nav__list-item><a href=/gallery/ title>Index 1</a></li><li class=nav__list-item><a href=/about/ title>About</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>ASCollectionNode 다루기 #1</h1><p><img src=/images/blog/1__I0CyqWilnxS__mYJPTXtN0Q.png alt></p><p>UICollectionView만 있으면 세상에 현존하는 어떠한 형태의 화면이든 자유롭게 그려낼 수 있는 아주 멋진 View에요.</p><p>주로 이러한 UI에서 사용되고 있어요.</p><ul><li>양방향 페이징할 수 있는 채팅화면</li><li>피드형태의 리스트</li><li>다양한 그리드 형태를 그려내는 UI</li><li>카로셀형태의 UI</li><li>기타 등등</li></ul><p>보통 일반적으로 많이 설계하는 형태가 Single Column Feed UI인데, 이는 특별히 신경쓸것도 없고 심지어 UITableView로 만들어도 이상하지가 않아요.</p><p><img src=/images/blog/1__pYNUojWA8BM3Wo__7fYjfAw.png alt>
<img src=/images/blog/1__LEtLd4xCsUwqoMH__KiVpXg.png alt></p><p>오늘 예기하고자 하는 부분은 Texture에서 제공하는 Proxy 형태의 UICollectionView 인 <strong>ASCollectionNode</strong>를 가지고 아주 기초적이지만 약간 복잡한 형태의 UI 설계 전략에 대해서 보여드릴까해요.</p><p><em>그리고 Texture는 어렵지 않고 똑같다라는 걸 예기하고 싶어요.</em></p><p>이번에 다뤄볼 UI 예시는 PugGram을 가져와봤어요.</p><p><img src=/images/blog/1__pVRDcbokwBvUalMEYRG8wQ.png alt></p><h4 id=section-선언>Section 선언</h4><p>PugGram에는 총 3가지의 Section으로 나눠져있어요.</p><ul><li>image (이미지나 다른 형태의 미디어 썸네일 이미지를 보여주는 섹션)</li><li>content (컨텐츠의 정보를 보여주는 섹션)</li><li>Related Card (연관된 카드를 보여주는 섹션, 헤더와 투칼럼으로 구성된 아이템들이 있어요.)</li></ul><p><img src=/images/blog/1__lvf06SQ6cB__cFWxbiG7QsQ.png alt></p><h4 id=ascollectionnode-initialization>ASCollectionNode initialization</h4><p>CollectionNode의 인스턴스를 만들어 주세요.</p><p><img src=/images/blog/1__vGT3GkERZ0NcIn7jX61NLQ.png alt></p><ul><li>위의 이미지에서 보았다싶이 Related Card Section에는 section header가 사용됨을 알 수 있어요. 따라서 아래의 코드와 같이 registerSupplementaryNode API를 이용하여 UICollectionView.elementKindSectionHeader 및 Footer를 register를 해줘야해요!</li><li>UICollectionViewFlowLayout default 방향은 vertical이라 특별히 지정해주진않았어요.</li><li>저희는 혼합된 레이아웃을 구현해야하기 때문에 별도로 minimum-inter-item-spacing 및 minimum-line-spacing, section-inset을 지정하지 않았어요.</li></ul><h4 id=ascollectiondatasource-상속-및구현>ASCollectionDataSource 상속 및 구현</h4><p><img src=/images/blog/1__fd__c4Ou31e5fRmbnHCKRug.png alt></p><p>이전에 만든 Section enum을 이용하여 위와 같이 코드를 구현할 수 있어요.</p><p>image와 content 섹션의 아이템은 임의로 1개 정도 반환하고 relatedCard 섹션은 임의로 20개를 반환해봤어요.</p><p><img src=/images/blog/1__7FHEuA6__fyUIbcQYD__oNBg.png alt></p><p>그리고 item에 대한 ASCellNode와 footer 및 header에 따른 supplementary element 대한 ASCellNode를 반환하는 로직을 구현해봤어요. (아주대충)</p><p><em>사실 위에서 설명한 부분들은 이번 내용과는 상당히 먼 이야기이므로 간단히 생략하도록 할께요. 자세한건</em> <a href=https://texture-kr.gitbook.io/wiki/><em>https://texture-kr.gitbook.io/wiki/</em></a> <em>여기서 다뤄져요. :]</em></p><h4 id=ascollectiondelegate-상속과-아이템에-대한-제약사이즈반환>ASCollectionDelegate 상속과 아이템에 대한 제약사이즈 반환</h4><p><img src=/images/blog/1____4sY1I0xHkiW6QxKnK5b9Q.png alt></p><p>저희가 설계하고자 하는 Related Card 영역의 아이템들은 위의 이미지와 같이 16.0pt의 간격을 유지하는 격자형태로 구현하고자 해요.</p><p>ASCollectionDelegate를 상속받으면 item들의 제약사이즈를 반환하는 constrainedSizeForItemAt API 가 있어요.</p><p>제약사이즈(ASSizeRange)는 minSize(CGSize), maxSize(CGSize)로 구성되어 있고 이를 기반으로 Texture의 Layout API가 Flexible 하게 frame를 계산해내는 방식으로 UI를 그려내요.</p><ul><li><em>*Texture에선 편의용으로 ASSizeRangeUnconstrained 와 ASSizeRangeZero두가지를 제공해주고 있어요. 자세한건</em> <a href=https://texture-kr.gitbook.io/wiki/><em>https://texture-kr.gitbook.io/wiki/</em></a></li></ul><p><img src=/images/blog/1__mdFF1G5h02Tvx__3XzEON__w.png alt></p><ul><li>image와 content 섹션은 Single-Column 이기 때문에 ASSizeRangeUnconstrained 정도면 충분해요.</li><li>Related Card 섹션은 각 spacing(16.0pt) 영역를 제외한 공간의 1/2 영역을 최대 Size (maxSize)로 두고 minSize는 .zero로 지정해서 제약사이즈를 반환해주면되요.</li></ul><h4 id=ascollectiondelegateflowlayout-상속과-각종-제약값반환>ASCollectionDelegateFlowLayout 상속과 각종 제약값 반환</h4><p><img src=/images/blog/1__5ZqN__GrPRXOHGezU5UQ0Hw.png alt></p><p>ASCollectionDelegateFlowLayout에 보면 위와같이 3가지의 API를 제공해요.</p><p><em>footer 및 header 에 대한 제약사이즈를 반환하는 API들과 그리고 section에 대한 inset(UIEdgeInset)을 반환하는 API가 있는데 충격적인건 minimum-inter-item-spacing과 minimum-line-spacing에 대한 API가 없었어요…</em> <a href=https://github.com/TextureGroup/Texture/pull/1768><em>https://github.com/TextureGroup/Texture/pull/1768</em></a></p><p><img src=/images/blog/1__PtpJw8ELe__3krd9khUQFdg.png alt></p><p>처음부터 말한 것처럼 ASCollectionNode는 UICollectionView proxy개념이기 때문에 당황하지 않고 주어진 대로 위의 코드와 같이 설계를 하면 다음과 같아요..</p><ul><li>footer는 사실상 사용하지 않기 때문에 SizeRange를 zero로 반환해요.</li><li>header는 Related Card에서만 필요하기 때문에 이를 제외한 나머지는 zero를 반환해요.</li><li>header와 마찬가지로 Related Card의 section만 좌/우로 16.0pt만 반환해요.</li></ul><p>좌우만 16.0pt를 반환하면 섹션에 대한 inset은 다음과 같이 적용된다 보시면 되요.</p><p><img src=/images/blog/1__2Y6Efz4kXNRvznzrl6s4nQ.png alt></p><h4 id=ascollectiondelegateflowlayout가-다-못하는건-uicollectionviewdelegateflowlayout에서-해결>ASCollectionDelegateFlowLayout가 다 못하는건 UICollectionViewDelegateFlowLayout에서 해결</h4><p>UI Framework 오픈소스고 규모가 커지다보면 사람들이 개발하는거다보니 놓치는 건 어쩔 수 없다 생각은 해요. 앞서 말했듯이 proxy개념이라 결코 UIKit에서 기본적으로 제공하는 API를 아예 못쓰는 건 아니에요! :]</p><p><em>Texture = UIKit + meta 같은 개념!</em></p><p>이제 우리에게 필요한건 두가지가 남았어요.</p><ul><li>minimum inter-item spcing: 아이템 간의 최소 간격</li><li>minimum line-spacing: 아이템 그룹과 그룹간의 간격</li></ul><p><img src=/images/blog/1__UcCWVMs3fzlV__LXGaCPW7Q.png alt>
<img src=/images/blog/1__FKbyM918qcD6rgcm6IQSyA.png alt></p><p>좀전에 언급 했듯이 저희는 16.0pt의 균일한 간격을 유지하는 것이 목표이기 때문에 아래와 같이 코드를 작성하면 끝나요.</p><p><img src=/images/blog/1__Ft6ohpnIw21hd1qxFviIfQ.png alt>
<img src=/images/blog/1__x4Jpefb2NxrL26gU0jpM1g.jpeg alt></p><p>사실 기본적으로 UIKit에서 제공하는 UICollectionView의 문서를 가볍게 읽어보면 간단히 구현할 수 있는 기능이지만 Texture를 초기에 접한 개발자들이 이러한 부분들 때문에 <strong>UIKit != Texture</strong>라는 공식과 <strong>러닝커브가 높다</strong>라는 인식을 가지는 경우가 많았던거 같아요.</p><p>이번 글을 통해서 많은 iOS 개발자분들이 Texture에 대한 편견을 버리고 <strong>재미있게 즐겼으면</strong> 하는 바램으로 적어봤어요. :)</p></div><div class=post__footer><span><a class=category href=/categories/ios/>iOS</a></span>
<span><a class=tag href=/tags/ios/>ios</a><a class=tag href=/tags/texture/>texture</a></span></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
Geektree0101
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></body></html>