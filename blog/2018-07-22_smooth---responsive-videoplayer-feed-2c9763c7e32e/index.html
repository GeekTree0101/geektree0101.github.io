<!doctype html><html dir=ltr lang=en data-theme class=html><head><title>Geektree0101
|
Smooth & responsive VideoPlayer Feed</title><meta charset=utf-8><meta name=generator content="Hugo 0.107.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="Geektree0101"><meta name=description content="이번 주제는 ASVideoNode로 간단한 Feed를 만들겁니다."><link rel=stylesheet href=/scss/main.min.b2e0cb07595e3519ab1193bb421914e06c0e26b0cc561fef23b3c6131d4d2ffa.css integrity="sha256-suDLB1leNRmrEZO7QhkU4GwOJrDMVh/vI7PGEx1NL/o=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.b1c4e6a10bdbab01f33fff9d78816ee68cf9a9a731f07668afd546a79924cb80.css integrity="sha256-scTmoQvbqwHzP/+deIFu5oz5qacx8HZor9VGp5kky4A=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.423dee17c62f55fa733a4ee13e00d523dfce88cc4f4ab4549a24ba36bd9de681.css integrity="sha256-Qj3uF8YvVfpzOk7hPgDVI9/OiMxPSrRUmiS6Nr2d5oE=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.b7d54133b27e5b4de15245b8e143de3e8ed2d674c706137274cedc9953f31917.css integrity="sha256-t9VBM7J+W03hUkW44UPePo7S1nTHBhNydM7cmVPzGRc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=https://geektree0101.github.io/blog/2018-07-22_smooth---responsive-videoplayer-feed-2c9763c7e32e/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.738c0e3a493854876aeab9e2316fd43f1936aeeac4cc6b3e60bb26456dba72ad.js integrity="sha256-c4wOOkk4VIdq6rniMW/UPxk2rurEzGs+YLsmRW26cq0=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Smooth & responsive VideoPlayer Feed"><meta name=twitter:description content="이번 주제는 ASVideoNode로 간단한 Feed를 만들겁니다."><meta property="og:title" content="Smooth & responsive VideoPlayer Feed"><meta property="og:description" content="이번 주제는 ASVideoNode로 간단한 Feed를 만들겁니다."><meta property="og:type" content="article"><meta property="og:url" content="https://geektree0101.github.io/blog/2018-07-22_smooth---responsive-videoplayer-feed-2c9763c7e32e/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2018-07-22T17:05:04+00:00"><meta property="article:modified_time" content="2018-07-22T17:05:04+00:00"><meta property="og:site_name" content="Hyeonsu Ha"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"blog","name":"Smooth \u0026 responsive VideoPlayer Feed","headline":"Smooth \u0026 responsive VideoPlayer Feed","alternativeHeadline":"","description":"
      이번 주제는 ASVideoNode로 간단한 Feed를 만들겁니다.


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/geektree0101.github.io\/blog\/2018-07-22_smooth---responsive-videoplayer-feed-2c9763c7e32e\/"},"author":{"@type":"Person","name":"Geektree0101"},"creator":{"@type":"Person","name":"Geektree0101"},"accountablePerson":{"@type":"Person","name":"Geektree0101"},"copyrightHolder":{"@type":"Person","name":"Geektree0101"},"copyrightYear":"2018","dateCreated":"2018-07-22T17:05:04.15Z","datePublished":"2018-07-22T17:05:04.15Z","dateModified":"2018-07-22T17:05:04.15Z","publisher":{"@type":"Organization","name":"Geektree0101","url":"https://geektree0101.github.io/","logo":{"@type":"ImageObject","url":"https:\/\/geektree0101.github.io\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/geektree0101.github.io\/blog\/2018-07-22_smooth---responsive-videoplayer-feed-2c9763c7e32e\/","wordCount":"671","genre":["iOS","Feed Service"],"keywords":["ios","feed","video"]}</script></head><body class="body theme--light"><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src="https://avatars.githubusercontent.com/u/19504988?v=4" alt="profile picture"><div class=sidebar__introduction-title><a href=/>Hyeonsu Ha</a></div><div class=sidebar__introduction-description><p>저는 Product Engineer이자 iOS App을 개발하고 있어요<br>제품설계, 가치전달, 협업문화에 대해 많은 관심을 가지고있어요.<br><br>I'm a Product Engineer & iOS software engineer.<br>I'm interested in product structure design, product value communication, and collaboration culture.<br><br>我是Product Engineer和iOS软件工程师。<br>我对产品结构设计、产品价值沟通、合作文化感兴趣。<br></p></div></div><ul class=sidebar__list><li class=sidebar__list-item><a href=https://www.linkedin.com/in/hyeonsu-ha-7ba02b112/ target=_blank rel=noopener aria-label=Linkedin title=Linkedin><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=h2s1880@gmail.com target=_blank rel=noopener aria-label=e-mail title=e-mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://github.com/GeekTree0101 target=_blank rel=noopener aria-label=github title=github><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://www.instagram.com/geektree0101/ target=_blank rel=noopener aria-label=instagram title=instagram><i class="fab fa-instagram fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
Geektree0101
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/ title>Index 0</a></li><li class=nav__list-item><a href=/gallery/ title>Index 1</a></li><li class=nav__list-item><a href=/about/ title>About</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Smooth & Responsive VideoPlayer Feed</h1><p><img src=/images/blog/0__OlEJjlPWXUDhjxQ6.jpeg alt></p><p><a href=http://texturegroup.org/docs/video-node.html title=http://texturegroup.org/docs/video-node.html><strong>ASVideoNode</strong><br>_Texture_texturegroup.org</a><a href=http://texturegroup.org/docs/video-node.html></a></p><p>이번 주제는 ASVideoNode로 간단한 Feed를 만들겁니다.</p><p>ASVideoNode에는 shouldAutoPlay라는 Property를 제공해줍니다.</p><p>이걸 Yes(True)로 해주면 didEnterVisibleState 에서 자동으로 play시켜주고 didExitVisibleState에서 pause해줍니다.</p><p>[State에 대해서는 <a href=http://texturegroup.org/docs/intelligent-preloading.html>여기</a> 참고]</p><p>여기까진 문제 없어보입니다. 그리고 asset or assetURL을 set value할 때는 반드시 Main-Thread에서 적용되어야 합니다.</p><p>내부적으로 Main Thread Assertion이 걸려있기 때문입니다.</p><p>그렇다면 다음과 같이 코드가 완성됩니다.</p><p>편의상 didLoad에서 setAsset을 해주도록 하겠습니다.</p><p>이렇게 만든 VideoCell을 100개를 reload했을 때 피드를 빠른속도로 스크롤하면 퍼포먼스가 과연 나올까요?</p><p>사실 그렇지 않습니다. 애초에 Texture에서 ASVideoNode를 만들때 비디오 리스트처럼 쓰라고 만들지 않았습니다. 뭐든 주는데로 그대로 받아 먹어서는 안됩니다. 코드도 마찬가지 입니다.</p><p>의외로 ASVideoPlayerNode는 pendingAsset이라는 property를 이용해서 Asset을 Pending시켜서 didEnterPreloadState 에서 asset을 안정적으로 setting 해줍니다만 역시나 큰 차이가 없습니다.</p><p>콩심은데 콩난다고 했던 선조의 지혜에 다시한번 감탄하고 갑니다.</p><p><a href=https://github.com/TextureGroup/Texture/tree/master/examples/ASDKTube title=https://github.com/TextureGroup/Texture/tree/master/examples/ASDKTube><strong>ASDKTubeExample</strong><br>_Texture - Smooth asynchronous user interfaces for iOS apps._github.com</a><a href=https://github.com/TextureGroup/Texture/tree/master/examples/ASDKTube></a></p><h4 id=결국-frame-drop이-심하다-싶을-정도로-일어나서-피드의-퍼포먼스와-오버헤드가-증가와-함께-제-스트레스도-같이-증가했다고-보시면되겠습니다>결국 Frame Drop이 심하다 싶을 정도로 일어나서 피드의 퍼포먼스와 오버헤드가 증가와 함께 제 스트레스도 같이 증가했다고 보시면 되겠습니다.</h4><p>한 동안 고민하다가 문득 이 노래가 생각나서 링크를 했습니다. 저는 개인적으로 노래들으면 노래랑 어울리는 코드가 절로 나옵니다.</p><p>저는 어떤 문제가 생기면 God 플랫폼들을 만져보면서 생각을 해보는 편입니다. 대표적으로 얼굴책(Facebook), 너의뱃살(Youtube) 등등이 있죠. 플랫폼 영어이름을 순 우리말로 표현한 것은 저의 애국심이라 보시면 되겠습니다. 그리고 Tube는 순우리말이 없어 그나마 가장 비슷한 제 뱃살이 생각나서 뱃살이라 적었습니다.</p><p>두 플랫폼에 대해서 테스트는 다음과 같이 하였습니다. 별거 없습니다</p><ol><li>개발자모드에서 Network 상태를 강제로 매우 열악한 환경으로 셋팅해서 어떻게 동작하는지 추론합니다.</li></ol><p>2. 스크롤에 따라서 비디오에 어떤 영향을 주는지 시각적인 변화를 통해서 추론합니다.</p><p>우선 Facebook은 Visible State에서 비디오를 로드하고 로드되면 자동 재생되는 것을 확인했습니다.</p><p>로드하는 단계라고 확정지은 이유는 System ActivityIndicator가 돌았기 때문입니다. (주관적인 견해)</p><p>그리고 스크롤에 따라 비디오 음량이 조절 되는 것을 확인할 수가 있었고 Exit시 pause를 동작시킵니다.</p><p>일단 Visible에서만 Video를 Load해주는 걸 알수가 있습니다.</p><p>두번째로는 Youtube인데 이건 피드에서 자동재생되는 기능을 사용자들 잘 모를꺼 같습니다. 왜냐하면 <strong>scrollViewDidEndDecelerating(_ scrollView: UIScrollView)</strong> 이 호출되면 그제서야 자동재생을 합니다. 아마 비디오 asset은 background까진 아니고 utility정도에서 비디오를 처리하는거 같습니다.</p><p>저도 사용자로서 이번 비디오 테스트하면서 처음 알았습니다. (저만 몰랐나요?)</p><p>일단 근본적인 Frame Drop원인은 두 플랫폼 덕분에 찾은 거 같습니다.</p><p>근본적인 이유는 100개의 VideoCell들이 Video Asset을 받아오고 Play를 내부 메커니즘에 따라서 잘 동작하지만 문제는 이들의 행위를 총 책임하는 책임자가 없기 때문에 100개의 VideoCell들은 무질서하게 동작하게 됩니다. 결국 재수없게 Visible State에 있는 비디오들이 동시에 여러개가 play되는 현상을</p><p>기술적으로는 ASVideoNode가 문제는 없습니다. 기능적인 동작에는 문제없지만, 각각 100개의 VideoCell들에게 알아서 동작하게 책임을 위임하는 행위가 사용자 경험성에 안좋다고 보면 되겠습니다.</p><p>저는 질서있는 걸 좋아합니다. 무질서하거나 시끌벅적한걸 싫어하기 때문에 Operation형님을 모셔왔습니다.</p><p>저는 간단히 BlockOperation정도 쓸꺼고 약간은 GCD도 같이 쓸껍니다.</p><p><a href=https://cocoacasts.com/choosing-between-nsoperation-and-grand-central-dispatch title=https://cocoacasts.com/choosing-between-nsoperation-and-grand-central-dispatch><strong>Choosing Between NSOperation and Grand Central Dispatch</strong><br>_While NSOperation and NSOperationQueue have been available since iOS 2, Grand Central Dispatch, GCD for short, was…_cocoacasts.com</a><a href=https://cocoacasts.com/choosing-between-nsoperation-and-grand-central-dispatch></a></p><p><a href=http://blog.canapio.com/128 title=http://blog.canapio.com/128><strong>[번역]스위프트에서 동시성에대한 모든것-Part1 : 현재편</strong><br>_제목: All about Concurrency in Swift - Part 1: The Present 현재 배포된 스위프트 언어에서는 Go나 Rust가 한것 처럼 아직 네이티브 동시성 기능을 가지지 않는다…_blog.canapio.com</a><a href=http://blog.canapio.com/128></a></p><p>위의 Article을 참고하시면 도움이 되실껍니다.</p><p>우선 VideoProcessing 이라는 struct을 만들어서 사용하고</p><p>두개의 Concurrent한 OperationQueue를 만들 껍니다. Video를 Load하는 Queue와 Play를 담당하는 Queue로 말이죠.</p><p>video load operation queue는 utility QoS가 적당하겠습니다. (베터리 부족시 Background로 해놓은 queue는 꺼진다는 말이 있다고 하는데 이건 좀 더 확인해보겠습니다.)</p><p>그리고 play는 userInitiated 또는 상위 Qos정도로 처리하면 좋겠습니다.</p><p>옛날에 군대에서 배식하는데 배식할때 최소 5~10사람씩 끊어서 입장해야 수월하게 배식을 할 수 있었습니다. 하지만 한번은 특식이 나오는 날이 였는데 동기나 선임들이 이러한 규칙을 어기고 40~50명이 개때처럼 몰려와서 배식이 엉망이 된 경험이 있어서 저는 OperationQueue의maxConcurrentOperationCount를 적절히 셋팅해줄 겁니다. 많이 안줄꺼에요.</p><p>load는 최대 3개의 Operation, play는 1개 정도 줄 껍니다.</p><p>어차피 사람은 두 눈으로 동영상 하나에 집중하기 때문에 우선 하나 Play Operaion Block이 수행되는 동안 다른 Video는 적절히 Concurrent하게 돌아가면 되겠습니다.</p><p>나중에 인류가 진화해서 눈이 4개가 된다면 play operation queue의 maxConcurrentOperationCount는 2개정도 주시면 되겠습니다.</p><p><img src=/images/blog/0__sXVmRmLd0aa__dpd4.jpg alt></p><p>참고로 빨간 잠자리는 한쪽당 4억 7천개의 눈을 가지고 있다고 합니다.</p><p>그리고 Play는 당장 Operation을 Visible State에서 동작 시키지 않고 GCD를 이용해 약 2.0sec 이후에 동작 시키도록 하겠습니다.</p><p>약간의 딜레이를 준건 페이스북과 유튜브 둘 다 그렇게 적용하였고, 이를 통해서 리소스낭비와 프레임 드랍을 방지하기 위함입니다.</p><p>만약 기획자가 “전부 다 바로바로 재생시켜주세요" 라고 한다면 NSRunLoop에 같이 넣어서 돌려버리십시오.</p><p>그리고 exit visible시에는 가차없이 해당 Cell의 Play, Load Operation을 가차없이 Cancel 시킵니다.</p><p>그리고 다시 enter visible 시에는 다시 Block Operation을 만들어서 PlayOperationQueue에 넣어줍니다.</p><blockquote><p>지나간 것은 지나간대로~</p></blockquote><p>그래도 이 정도면 퍼포먼스가 상당히 좋아진 것을 확인 할 수가 있겠습니다.</p><p>그럼 여러분 안녕~</p></div><div class=post__footer><span><a class=category href=/categories/ios/>iOS</a><a class=category href=/categories/feed-service/>Feed Service</a></span>
<span><a class=tag href=/tags/ios/>ios</a><a class=tag href=/tags/feed/>feed</a><a class=tag href=/tags/video/>video</a></span></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
Geektree0101
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></body></html>