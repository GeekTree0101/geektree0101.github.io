<!doctype html><html>
<head>
<title>Hello Knot // Geektree0101</title>
<meta charset=utf-8>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1">
<meta name=description content="최근 클린 아키텍처 한글번역판이 나와서 열심히 읽으면서 앞으로 어떤 라이브러리를 만들어서 iOS커뮤니티와 세상?에 기여를 해볼까 수 많은 고민을 해봤었습니다.">
<meta property="og:title" content="Hello Knot">
<meta property="og:description" content>
<meta property="og:type" content="website">
<meta property="og:locale" content="en">
<meta property="og:url" content="/blog/blog14/">
<link rel="shortcut icon" href=/favicon.ico>
<link href=/webfonts/ptserif/main.css rel=stylesheet type=text/css>
<link href=/webfonts/source-code-pro/main.css rel=stylesheet type=text/css>
<link rel=stylesheet href=/css/style.css>
<link rel=stylesheet href=/css/article-toc.css type=text/css>
<meta name=generator content="Hugo 0.92.0">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3090955890879034" crossorigin=anonymous></script>
</head>
<body>
<div id=container>
<header id=header>
<div id=header-outer class=outer>
<div id=header-inner class=inner>
<a id=main-nav-toggle class=nav-icon href=javascript:;></a>
<a id=logo class=logo-text href=/>Geektree0101</a>
<nav id=main-nav>
<a class=main-nav-link href=/about>About</a>
<a class=main-nav-link href=/categories>Categories</a>
<a class=main-nav-link href=/tags>Tags</a>
</nav>
<nav id=sub-nav>
<div id=search-form-wrap>
</div>
</nav>
</div>
</div>
</header>
<section id=main class=outer>
<article class="article article-type-post" itemscope itemprop=blogPost>
<div class=article-inner>
<header class=article-header>
<h1 class=article-title itemprop=name>Hello Knot</h1>
</header>
<div class=article-meta>
<a href=/blog/blog14/ class=article-date>
<time datetime=2019-08-23T01:08:50.548+00:00 itemprop=datePublished>2019-08-23</time>
</a>
<div class=post-categories>
<div class=article-category>
<a class=article-category-link href=/categories/ios>iOS</a>
</div>
</div>
<div class=article-comment-link-wrap>
<a href=/blog/blog14/#disqus_thread class=article-comment-link>Comments</a>
</div>
</div>
<div class=article-entry itemprop=articleBody>
<p><img src=/images/blog/0__ZyM3mDA67vy6eboU.png alt></p>
<p><a href="https://book.naver.com/bookdb/book_detail.nhn?bid=15303798" title="https://book.naver.com/bookdb/book_detail.nhn?bid=15303798"><strong>클린 아키텍처</strong><br>
_&ldquo;살아있는 전설이 들려주는 실용적인 소프트웨어 아키텍처 원칙"소프트웨어 아키텍처의 보편 원칙을 적용하면 소프트웨어 수명 전반에서 개발자 생산성을 획기적으로 끌어올릴 수 있다. 《클린 코드》와 《클린 코더》의…_book.naver.com</a><a href="https://book.naver.com/bookdb/book_detail.nhn?bid=15303798"></a></p>
<p>최근 클린 아키텍처 한글번역판이 나와서 열심히 읽으면서 앞으로 어떤 라이브러리를 만들어서 iOS커뮤니티와 세상?에 기여를 해볼까 수 많은 고민을 해봤었습니다.</p>
<p>요 몇년간 RxSwift가 국내에서 흥행 하면서 사용하는 회사들도 많이 늘어나고 있고 수 많은 여러 관련 라이브러리들이 쏟아져나왔다. 예를 들면, ReactorKit같은 훌륭한 프레임워크같은 것들.</p>
<p>필자는 RxSwift좋아하고 Texture 관련된 여러 테크닉들도 연구하고 있는 상황속에서 여러가지 시도 끝에 일주일전 <strong>Knot</strong>이라는 라이브러리를 배포하게 되었습니다. (짞짞짞)</p>
<p><img src=/images/blog/1__XAAvK3qzu8VaYGxcClocWw.png alt></p>
<p>ReactorKit 쓰면 되지 라는 의문도 스스로에게 피드백 해보기도 했는데, 몇 년전 RxCocoa-Texture를 이용해서 Node의 UI Components properties에 bind하면서 한가지의 잘못된 부분을 발견했었습니다.</p>
<p><img src=/images/blog/1__D__KEJhnPDdWYArWtaqbfdw.png alt></p>
<p>binding 과정에서</p>
<ul>
<li>setNeedsLayout을 지나치게 남발하고 있지않은가?,</li>
<li>보일러플레이트를 쓰고 있는게 아닌가?</li>
<li>디버깅하기가 쉽지 않았다. debug operator를 써줘야한다.</li>
<li>예측하기가 쉽지는 않다.</li>
</ul>
<blockquote>
<p>사실 위의 코드는 세상 아무일 없다는 듯이 매우 잘 동작한다.</p>
</blockquote>
<p>물론 위의 경우 다음과 같은 장점은 있을 수가 있다.</p>
<ul>
<li>중복에 대한 처리</li>
<li>다양한 Rx operators을 자유롭게 쓸 수 있음 (장점인진 모르겠음)</li>
<li>etc…</li>
</ul>
<p>반응형 노드를 만들다 보면 노드와 1:1 로 Reactor 를 만들던가 아니면 유사한 동작을 하는 ViewModel을 만들게 됩니다.</p>
<p>하지만, 현실은 항상 변화하는 기획과 UI Design spec, 비즈니스 로직들에 비해 매우 짧은 생명주기를 가지는 게 UI영역이지 아니한지?</p>
<p>필자는 ViewModel이 많은 일을 하기를 바라지 않고, ViewModel내에서 여러 Repository나 Service들과 함께 공존하기를 바라지 않는 않습니다.</p>
<blockquote>
<p>나중에 코드 덜어낼 때 맴찢</p>
</blockquote>
<p>따라서 ViewModel은 View와 1:1로 매칭되더라도 생산성과 개발의 편의성, 용이성을 위해 아래와 같은 조건들을 가져야 한다고 생각합니다.</p>
<ul>
<li>빠른 생산성</li>
<li>UI Component 의 재사용성</li>
<li>ViewModel은 UI Components 제어에 직접적으로 필요한 프로퍼티만 가진다. (hidden, show, title, description, imageURL etc..)</li>
<li>예측 가능해야한다.</li>
<li>비즈니스 로직들과 분리가 가능해야하며, 엔터티를 직접적으로 건들여서는 안된다.</li>
</ul>
<p><img src=/images/blog/0__ZyM3mDA67vy6eboU.png alt></p>
<p>위의 그림을 보면 UI와 Controller는 분리되어있다. 보통 iOS 첫시작하면 MVC패턴을 주로 활용하게 되는데, 이러한 Controller 가 Massive해지는 경향이 커지다 보니 MVVM이나 다른 수 많은 아키텍처와 프레임워크들이 나오기 시작했습니다.</p>
<p>Texture를 사용한 개발자는 알다싶이 UIViewController가 아닌 UIViewController subclass형태 및 제네릭형태로 ASDisplayNode 및 subclass를 base로 하는 <strong>ASViewController</strong> class가 있다는 걸 알 수 있을 겁니다.</p>
<h4 id=1-viewcontroller와-view정리하기>1. ViewController와 View 정리하기</h4>
<p>우선, 최대한 UI가 해야하는 일들을 전적으로 Node에다 맡기는 방법으로 리펙토링하면</p>
<p>before:</p>
<p>class VC: ASViewController {</p>
<p>let targetNode = ASDisplayNode()</p>
<p>}</p>
<p>after:</p>
<p>class TargetNode: ASDisplayNode {</p>
<p>}</p>
<p>class VC: ASViewController {</p>
<p>}</p>
<p>위의 코드와 같이 변경하게 되면 이점음</p>
<ul>
<li>ViewController는 단순 presenter과 node간의 브릿징 역할을 하게 됌</li>
<li>Scene의 LifeCycle과 이외 요소들에 좀 더 집중할 수 있게 됌 (viewWillAppear, viewWillDisappear etc)</li>
</ul>
<p>그러면 다음과 같은 파일 구조를 가지게 될 겁니다.</p>
<p><img src=/images/blog/1__DspHDYcOeaxR__COGYH5UIA.png alt></p>
<p>Adapter에 Controller와 Presenter가 있으며, View dir에 노드들이 있습니다.</p>
<blockquote>
<p>도메인도 정리하긴 해야하는데.. 이건 이번글에서 다룰 부분은 아니니 패스</p>
</blockquote>
<p>위와 같은 형태에서 노드(뷰)들은 외부에서 재사용 할 수 있으며 버려지더라도 Domain은 UI영역에 대해서 완벽히 분리되며, Adapter는 사용하는 View의 상태값에 대한 타입만 바꿔주면 언제든 다시 재사용 할 수가 있을 껍니다.</p>
<blockquote>
<p>(사실 여기에 대해서 앞으로 좀 더 개선해서 다룰 예정입니다.)</p>
</blockquote>
<h4 id=2-knot-state와-updatemethod>2. Knot State와 update method</h4>
<p>우선 Node에 Knotable을 상속받고 KnotState를 상속받은 State struct을 만들어줍니다. KnotState 를 상속하는 이유는 default 상태값을 지정하기 위함입니다. static defaultState: method를 작성하라고 알려줄껍니다.</p>
<p><img src=/images/blog/1__2nXtkoZiwUElAjFor__r__Ww.png alt></p>
<p>그리고 Knotable의 State를 지정하면 아래와같이 update:state method를 정의해라고 말해줄껍니다.</p>
<p><img src=/images/blog/1__9xzkB9b3DokEuwmLDHoZQA.png alt></p>
<p>이전 RxCocoa-Texture와 같이 직접적으로 setNeedsLayout을 위한 보일러 플레이트 코드를 쓰실 필요도 없고 setNeedsLayout을 직접적으로 호출하실 필요가 없습니다. 정말 UI Components의 상태값만 지정해주며, Then 디펜던시가지고 갈까 고민하다 그냥 ASDisplayNode 및 subclass를 위한 update block 을 제공했습니다.</p>
<p>자세한 건, 아래의 코드(Knotable.swift)를 통해 확인가능합니다.</p>
<p><img src=/images/blog/1__j3IEFpWqC95BFze6TBEQrA.png alt></p>
<h4 id=3-sink><strong>3. Sink</strong></h4>
<p>비즈니스로직에 따라 만들어지진 규칙들을 바탕으로 프레젠터에서 State를 만들게 되면 이것을 View(노드)에 적용을 해줘야합니다.</p>
<p>이러한 역할을 하는 method가 Sink입니다.</p>
<p><img src=/images/blog/1__e3uO0I5f0yx7Pibgp63w8w.png alt></p>
<p>Sink는 setNeedsLayout을 포함하지않고 단순히 node에 state값만 반영해줄 뿐입니다. 필요에 따라서 sink후에 setNeedsLayout 또는 이외 Transition API를 활용하여 Re-layout할 수가 있습니다.</p>
<h4 id=4-pipe-stream>4. Pipe & Stream</h4>
<p>그렇다면 Observable을 binding할 수는 없을까?</p>
<p>물론 Knot는 이러한 부분도 제공해준다. 좀 더 편의를 위해서 <a href=https://github.com/GeekTree0101/Knot/blob/master/Knot/Classes/Knot%2BConvenience.swift>Knot+Convenience.swift</a> 에서 좀 더 쉬운 pipe라는 method를 제공해준다.</p>
<p><img src=/images/blog/1__xgNsmx56ESV1oAPpNSttiw.png alt></p>
<p>pipe가 받는 파라메터는 Knotable를 상속받은 노드이며 해당 노드의 상태값에 대한 Observable Event 를 받습니다.</p>
<p>동작 플로우는 다음과 같습니다.</p>
<p>이벤트 -> update: -> setNeedsLayout or layoutIfNeeds</p>
<p>내부적으로 setNeedsLayout을 호출하기 때문에 크게 신경 쓰지 않아도 됩니다. 하지만, Transition(animation) 이 필요한 경우라면 subscribe: 후 sink + transition API 를 사용하기를 권장합니다. (개선예정)</p>
<p>stream은 말그대로 stream이며 pipe보다 하위개념으로 사용됩니다.</p>
<p>bind method와 stream을 합친것이 pipe이며 stream을 사용하게 된다면 다음과 같이 사용할 수 있습니다.</p>
<p>Observable.just(State.init(&mldr;)).bind(to: node.stream)</p>
<h4 id=마무리>마무리</h4>
<p>두서없이 쓰기는 했지만 필자가 하고싶은 말을 정리하면 다음과 같습니다.</p>
<ul>
<li>ViewModel도 멍청해야합니다. 똑똑해야 한다면 프리젠터가 똑똑해야하고 재사용가능해야합니다.</li>
<li>나뭇잎(뷰)의 라이프사이클은 짧고 뿌리(도메인과 비즈니스로직)는 깊습니다.</li>
<li>반응형 뷰(노드)는 예측이 가능해야하며 읽기 쉽고 디버깅이 용이해야합니다.</li>
</ul>
<p>이 외에 상세한 API Guide는 <a href=https://github.com/GeekTree0101/Knot/blob/master/README.md>README.md</a> 에 있으며, 많은 컨트리뷰트와 이슈 참여 부탁드립니다. :)</p>
</div>
<div class=article-toc>
<h3>Contents</h3>
<nav id=TableOfContents>
<ul>
<li>
<ul>
<li></li>
</ul>
</li>
</ul>
</nav>
</div>
<footer class=article-footer>
<ul class=article-tag-list>
<li class=article-tag-list-item>
<a class=article-tag-list-link href=tags/ios>ios
</a>
</li>
</ul>
</footer>
</div>
<nav id=article-nav>
<a href=/blog/blog13/ id=article-nav-newer class=article-nav-link-wrap>
<div class=article-nav-title><span>&lt;</span>&nbsp;
맛있는 반응형 스파게티 레시피
</div>
</a>
<a href=/blog/blog15/ id=article-nav-older class=article-nav-link-wrap>
<div class=article-nav-title>글쓰게 하는 힘 (에디터 1편)&nbsp;<span>></span></div>
</a>
</nav>
</article>
<div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//https-geektree0101-github-io.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</section>
<footer id=footer>
<div class=outer>
<div id=footer-info class=inner>
&copy; 2022 Geektree0101
<br>
Powered by <a href=https://gohugo.io target=_blank>Hugo</a> with theme <a href=https://github.com/carsonip/hugo-theme-minos target=_blank>Minos</a>
</div>
</div>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/tomorrow-night.min.css integrity="sha256-2wL88NKUqvJi/ExflDzkzUumjUM73mcK2gBvBBeLvTk=" crossorigin=anonymous>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js integrity="sha256-KbfTjB0WZ8vvXngdpJGY3Yp3xKk+tttbqClO11anCIU=" crossorigin=anonymous></script>
<script>hljs.initHighlightingOnLoad()</script>
<script>document.getElementById('main-nav-toggle').addEventListener('click',function(){var a=document.getElementById('header');a.classList.contains('mobile-on')?a.classList.remove('mobile-on'):a.classList.add('mobile-on')})</script>
</footer>
</div>
</body>
</html>