<!doctype html><html>
<head>
<title>Vapor, 테스트 주도 개발을 해가면서 Slack slash command 만들기 // Geektree0101</title>
<meta charset=utf-8>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1">
<meta name=description content="왜 Vapor를 선택하게 되었는지, 어떠한 방식으로 TDD를 해가면서 간단한 Slack slash command API를 만들었는지에 대한 과정을 적어봤어요,.">
<meta property="og:title" content="Vapor, 테스트 주도 개발을 해가면서 Slack slash command 만들기">
<meta property="og:description" content>
<meta property="og:type" content="website">
<meta property="og:locale" content="en">
<meta property="og:url" content="/blog/blog7/">
<link rel="shortcut icon" href=/favicon.ico>
<link href=/webfonts/ptserif/main.css rel=stylesheet type=text/css>
<link href=/webfonts/source-code-pro/main.css rel=stylesheet type=text/css>
<link rel=stylesheet href=css/style.css>
<meta name=generator content="Hugo 0.91.2">
</head>
<body>
<div id=container>
<header id=header>
<div id=header-outer class=outer>
<div id=header-inner class=inner>
<a id=main-nav-toggle class=nav-icon href=javascript:;></a>
<a id=logo class=logo-text href=/>Geektree0101</a>
<nav id=main-nav>
<a class=main-nav-link href=/about>About</a>
<a class=main-nav-link href=/categories>Categories</a>
<a class=main-nav-link href=/tags>Tags</a>
</nav>
<nav id=sub-nav>
<div id=search-form-wrap>
</div>
</nav>
</div>
</div>
</header>
<section id=main class=outer>
<article class="article article-type-post" itemscope itemprop=blogPost>
<div class=article-inner>
<header class=article-header>
<h1 class=article-title itemprop=name>Vapor, 테스트 주도 개발을 해가면서 Slack slash command 만들기</h1>
</header>
<div class=article-meta>
<a href=/blog/blog7/ class=article-date>
<time datetime=2020-11-13T22:28:49.334+00:00 itemprop=datePublished>2020-11-13</time>
</a>
<div class=post-categories>
<div class=article-category>
<a class=article-category-link href=/categories/server>Server</a>
</div>
</div>
</div>
<div class=article-entry itemprop=articleBody>
<h3 id=고린이golang-입문기시절>고린이(golang 입문기)시절</h3>
<p><img src=/images/blog/0__JHVa3o6dFCX83a0r.png alt></p>
<p>비록 iOS 앱을 개발하는 한낱의 모바일 개발자이지만, 지난 몇 달간 회사에 재직중인 고퍼(Gopher)분들로 부터 영감을 받아 <a href=https://echo.labstack.com/>Echo framework</a>기반으로 간단한 업무용 Slack slash command 로직은 만든적이 있었습니다.</p>
<p><img src=/images/blog/1__IN9z0xm3UCIOI3k73pwXYg.png alt></p>
<p>처음엔 코드를 작성하기 쉬웠지만 가면 갈수록 어렵게 느껴짐과 동시에 서버사이드 개발과 테스트가 미숙하다보니 구조는 오히려 망가져가고 정상적인 테스트 코드를 작성하지 못해서. 결국, 나는 망가진 코드를 직면하게 될 수 밖에 없었습니다. :[</p>
<p>제일 중요한건 혼자 이걸 유지보수 하다보니 외로움도 없잖아 있었습니다…</p>
<h3 id=구관이-명관>구관이 명관</h3>
<p>결국 제가 내린 결론은 처음부터 다시 새로 만드는 것!</p>
<p>새로만들기 전에 고려했던 포인트들은 다음과 같습니다.</p>
<ul>
<li>나와 함께 일하는 iOS 개발자들도 함께 만들어 나갈 수 있어야함</li>
<li>즐거운 테스트 주도 개발(의식의 흐름대로 코드를 작성하는 것을 피하고 싶음)</li>
<li>유연한 구조설계(특히, 추상화 가능한 언어를 사용하는 프레임워크!)</li>
</ul>
<p>위 3가지중 이번에 가장 중요한 포인트는 함께하는 부분에 집중했었고, 동료들은 Swift에 친숙하고 언어의 특성을 깊게 잘 알고 있는 상황이기 때문에, 결국 Swift Server Side Framework중 Vapor를 선택하게 되었습니다.</p>
<h3 id=framework-선택하기>Framework 선택하기</h3>
<p>Swift Server Side Framework는 대표적으로 크게 3가지가 있습니다.</p>
<ul>
<li>Kitura, <a href=https://github.com/Kitura/Kitura>https://github.com/Kitura/Kitura</a></li>
<li>Perfact, <a href=https://github.com/PerfectlySoft/Perfect>https://github.com/PerfectlySoft/Perfect</a></li>
<li>Vapor, <a href=https://github.com/vapor/vapor>https://github.com/vapor/vapor</a></li>
</ul>
<p>수 많은 Swift Server Side Framework중 굳이 Vapor를 선택한 이유는</p>
<p>Kitura는 거의 관리가 안되는게 실정이고 문제나 여러 이슈들이 쌓여있는게 현실입니다. 더군다나 3년전에 봤던 때와 비교했을 때 큰 변화나 발전이 없었습니다.</p>
<p>Perfact도 몇 년 동안 큰 변화는 없었지만, <a href=https://github.com/apple/swift-nio>Apple Swift-NIO</a>기반 작업한 <a href=https://github.com/PerfectlySoft/Perfect-NIO>레포지토리는 여전히 알파상태</a>에 있고 DX(Developer Experience)측면에서 아직까지 좋지 않은 느낌 없잖아 있었습니다.</p>
<p>마지막으로 남은게 Vapor인데, Vapor는 2020년 4월에 <a href=https://github.com/apple/swift-nio><strong>Swift-NIO</strong></a> 기반으로 구조 재설계 이후 꾸준한 활동성을 보여주고 있음과 동시에 Kitura나 Perfact와 비교했을 때 상대적으로 많은 장점과 좋은 DX를 제공하고 있어서 망설임 없이 Vapor를 채택하게 되었습니다.</p>
<h3 id=환경>환경</h3>
<ul>
<li>Vapor 4.0</li>
<li>Swift 5.2</li>
<li>SPM(Swift Package Manager) 기반 구성</li>
<li>돈쓰기 싫어서? Heroku에 Deploy</li>
</ul>
<h3 id=구조-설계>구조 설계</h3>
<p><img src=/images/blog/1__T4__FEemr1THb71parNwD4Q.png alt></p>
<p>Vapor framework자체에선 RouteCollection을 기반으로 한 MVC 구조를 가지고 있습니다. (Ruby on rails나 Django와 같은 다른 보편적인 프레임워크의 구조와 동일합니다.)</p>
<p>Controller(RouteCollection)는 중재자 역할을 하게 되지만, 비즈니스 로직이나 외부 서비스와의 연결등등이 많아지게 되면 <strong>Controller는 결국 Massive</strong>해지게 되고 테스트 하기도 쉽지않아서 수정이나 기능을 추가하다 보면 원치 않는 사이드 이펙트 버그가 생기고 프로덕트가 쉽게 무너지기 쉽습니다.</p>
<p>이를 피하기 위해서 나는 새로운 객체 두가지를 Controller로 부터 분리했습니다.</p>
<ul>
<li>Worker: 비즈니스 로직을 주로담당</li>
<li>Service: 외부 서비스 로직을 담당</li>
</ul>
<p>worker와 service는 각자 interface를 상속받아 구현을 합니다.</p>
<p>// worker</p>
<p>protocol CmdWorkerLogic { &mldr; }</p>
<p>struct CmdWorker: CmdWorkerLogic { &mldr; } // Production 용</p>
<p>struct CmdBetaWorker: CmdWorkerLogic { &mldr; } // Beta 용 (임의 작성)</p>
<p>// service</p>
<p>protocol GithubServiceLogic { &mldr; }</p>
<p>struct GithubService: GithubServiceLogic { &mldr; }</p>
<p><img src=/images/blog/1__oPlctJxFpCApQqRLlMpDog.png alt></p>
<p>그리고 controller에는 아래의 코드와 같이 작성합니다.</p>
<p>import Vapor</p>
<p>struct CmdController: RouteCollection, Then {</p>
<p>var worker: CmdWorkerLogic = CmdWorker()<br>
var service: GithubServiceLogic = GithubService()</p>
<p>}</p>
<h3 id=테스트-설계>테스트 설계</h3>
<h4 id=test-double준비>Test Double 준비</h4>
<p>이후, Worker와 Service에 대한 Spy객체를 준비합니다.</p>
<p><em>WorkerSpy 객체 예시</em></p>
<p>import Vapor<br>
@testable import App</p>
<p>final class CmdWorkerSpy: CmdWorkerLogic {</p>
<p>var pullReqeustCalled: Int = 0<br>
var pullRequestStub: SlackMessage = .init()</p>
<p>func pullRequest(prs: [GithubPullRequest]) -> SlackMessage {</p>
<pre><code>self.pullRequestCalled += 1  
return self.pullRequestStub  
</code></pre>
<p>}</p>
<p>// ~~~ 생략 ~~~<br>
}</p>
<p>ServiceSpy 객체 예시</p>
<p>import Vapor<br>
@testable import App</p>
<p>final class GithubServiceSpy: GithubServiceLogic {</p>
<p>var getPullRequestsCalled: Int = 0<br>
var getPullRequestsStub: EventLoopFuture&lt;[GithubPullRequest]>?</p>
<p>func getPullRequests(req: Request) -> EventLoopFuture&lt;[GithubPullRequest]> {</p>
<pre><code>self.getPullRequestCalled += 1  
return self.getPullRequestStub ??  
req.eventLoop.makeFailedFuture(Abort(.internalServerError))  
</code></pre>
<p>}</p>
<p>// ~~~ 생략 ~~~<br>
}</p>
<ul>
<li>XXX Called 형태로 Integer를 선언한 이유는, 호출했는지 판단 할 수 있으며 호출 횟수까지 테스트 과정에서 식별하기 위함</li>
<li>XXX Stub 프로퍼티를 선언해 스터빙을 함으로써 다양한 테스트 시나리오 작성에 도움을 줍니다.</li>
<li>사실 Mockito나 별다른 Stubbing 서드파티 굳이 쓰지 않고 Test Double을 위와 같은 형태로 간단히 구현할 수 있습니다. (<a href=https://clean-swift.com/test-driven-development-using-clean-architecture-part-1/>Clean Swift TDD Part 1</a>)</li>
</ul>
<h4 id=unit-test작성>Unit Test 작성</h4>
<p>import Vapor<br>
import XCTVapor<br>
import Nimble</p>
<p>@testable import App</p>
<p>final class CmdControllerTests: XCTestCase {</p>
<p>var app: Application!</p>
<p>// sut: system under test<br>
var sut: CmdController!</p>
<p>// test doubles<br>
var githubService: GithubServiceSpy! <br>
var worker: CmdWorkerSpy!</p>
<p>override func setUp() {</p>
<p>self.githubService = GithubServiceSpy()<br>
self.worker = CmdWorkerSpy() <br>
self.sut = CmdController().with { <br>
$0.worker = self.worker <br>
$0.service = self.githubService <br>
}</p>
<p>self.app = Application(.testing).then { <br>
try? configure($0) <br>
try? $0.register(collection: self.sut)<br>
}</p>
<p>}</p>
<p>override func tearDown() {</p>
<p>self.app.shutdown() <br>
}</p>
<p>}</p>
<ul>
<li>setUp과 tearDown 구성</li>
<li>Nimble은 빠른 테스트 타이핑에 도움을 주기 위해서 import</li>
<li>with 나 then은 임의로 <a href=https://github.com/devxoul/Then>Then</a>에서 가져와서 사용했어요.</li>
</ul>
<p>그리고 아래의 코드와 같이 Worker와 Service Spy객체에 스터빙을 기반으로한 Test Code를 작성합니다.</p>
<p>// MARK: - Pull Request</p>
<p>extension CmdControllerTests {</p>
<p>func test_post_cmd_pull_request_success() throws {<br>
// given <br>
self.githubService.getPullRequestsStub = self.app.eventLoopGroup.future([GithubPullRequest()])</p>
<p>self.worker.pullRequestStub = SlackMessage()</p>
<p>// when <br>
try self.app.test(.POST, &ldquo;/cmd&rdquo;, afterResponse: { res in <br>
// then <br>
expect(self.githubService.getPullRequestsCalled) == 1<br>
expect(self.worker.pullRequestCalled) == 1 <br>
expect(res.status) == .ok <br>
})<br>
}</p>
<p>func test_post_cmd_pull_request_failed() throws { <br>
// given <br>
self.worker.isValidStub = true<br>
self.worker.getTargetStub = .init(target: .pullRequest, query: nil)</p>
<pre><code>self.githubService.getPullRequestsStub = self.app.eventLoopGroup.future(error: Abort(.internalServerError)) 

// when      
try self.app.test(.POST, &quot;/cmd&quot;, afterResponse: { res in    
 // then        
 expect(self.githubService.getPullRequestsCalled) == 1       
 expect(self.worker.pullRequestCalled) == 0      
 expect(res.status) == .internalServerError      
})    
</code></pre>
<p>}</p>
<p>}</p>
<ul>
<li>given: 제안된 시나리오를 기반으로 worker나 service에 필요한 스터빙을 합니다.</li>
<li>when: 제안된 시나리오를 동작시킵니다.</li>
<li>then: when에 따른 결과값을 체크합니다.</li>
</ul>
<p>그리고 test를 돌려주면 해당 테스트는 실패하거나 부분적으로 성공했음을 알 수 있습니다. 즉, <strong>Red상태</strong>에 들어갑니다.</p>
<p><img src=/images/blog/1__ZjZnK3ZDJL03uTXKWpzZKQ.png alt></p>
<p>위와 같이 테스트를 작성하고 Worker와 Service의 실질적인 객체 내용을 구현을 합니다. <strong>Green 상태</strong> 즉, 테스트가 온전히 성공상태가 될 때까지 말입니다.</p>
<p>struct CmdWorker: CmdWorkerLogic {</p>
<p>func pullRequest(prs: [GithubPullRequest]) -> SlackMessage {<br>
// 구현<br>
}<br>
}</p>
<p>struct GithubService: GithubServiceLogic { &mldr; 구현 &mldr; }</p>
<p>struct CmdController: RouteCollection { &mldr; 구현 &mldr; }</p>
<p>이후 Controller에 새로운 기능을 추가하거나, 비즈니스 로직 변경사항이 있으면 변경(<strong>Refactor</strong>) 을 통해서 다시 Red상태에 들어가게 되고 위와 같은 과정 반복을 통해 Green상태로 만들어가면서 안정적으로 프로덕트를 설계합니다.</p>
<p><img src=/images/blog/1__e8MNESnv9BdGlhNvwJDetg.png alt></p>
<h3 id=끝으로>끝으로</h3>
<p>Golang으로 지속가능한 개발을 하지 못한점은 아쉽긴하지만, 이번 프로젝트를 통해서 iOS팀 동료분들도 읽기 쉽고 함께 참여가능한 프로젝트를 만들었다는 부분에 대해서 큰 의미를 가지게 되었습니다.</p>
<p>최근에는 <a href=https://github.com/vapor/leaf>Leaf</a>기반으로 슬렉 Hook을 활용한 선택적 채널에 대한 전역적 공지사항 웹앱도 만들면서 아직까진 특별한 불편함 없이 잘 사용하고 있어서 마냥 행복합니다. :]</p>
<p>Swift-NIO와 Swift 그리고 Vapor의 무궁한 발전과 앞날을 기원하며 이 정도로 글 마무리하겠습니다.</p>
<p>읽어 주셔서 감사합니다.</p>
<p>더 궁금하신 내용이 있으시거나 수정할 내용이 보이신다면 언제든 편안하게 <a href=https://github.com/GeekTree0101/GeekTreeQnA>https://github.com/GeekTree0101/GeekTreeQnA</a> 에 이슈남겨주시면 감사하겠습니다.</p>
</div>
<div class=article-toc>
<h3>Contents</h3>
<nav id=TableOfContents>
<ul>
<li>
<ul>
<li><a href=#고린이golang-입문기시절>고린이(golang 입문기)시절</a></li>
<li><a href=#구관이-명관>구관이 명관</a></li>
<li><a href=#framework-선택하기>Framework 선택하기</a></li>
<li><a href=#환경>환경</a></li>
<li><a href=#구조-설계>구조 설계</a></li>
<li><a href=#테스트-설계>테스트 설계</a></li>
<li><a href=#끝으로>끝으로</a></li>
</ul>
</li>
</ul>
</nav>
</div>
<footer class=article-footer>
<ul class=article-tag-list>
<li class=article-tag-list-item>
<a class=article-tag-list-link href=tags/vapor>vapor
</a>
</li>
<li class=article-tag-list-item>
<a class=article-tag-list-link href=tags/swift>swift
</a>
</li>
<li class=article-tag-list-item>
<a class=article-tag-list-link href=tags/server>server
</a>
</li>
</ul>
</footer>
</div>
<nav id=article-nav>
<a href=/blog/blog6/ id=article-nav-newer class=article-nav-link-wrap>
<div class=article-nav-title><span>&lt;</span>&nbsp;
Tasting a flutter 😋
</div>
</a>
<a href=/blog/blog8/ id=article-nav-older class=article-nav-link-wrap>
<div class=article-nav-title>iOS 14 CTTelephonyNetworkInfo&nbsp;<span>></span></div>
</a>
</nav>
</article>
</section>
<footer id=footer>
<div class=outer>
<div id=footer-info class=inner>
&copy; 2022 Geektree0101
<br>
Powered by <a href=https://gohugo.io target=_blank>Hugo</a> with theme <a href=https://github.com/carsonip/hugo-theme-minos target=_blank>Minos</a>
</div>
</div>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/tomorrow-night.min.css integrity="sha256-2wL88NKUqvJi/ExflDzkzUumjUM73mcK2gBvBBeLvTk=" crossorigin=anonymous>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js integrity="sha256-KbfTjB0WZ8vvXngdpJGY3Yp3xKk+tttbqClO11anCIU=" crossorigin=anonymous></script>
<script>hljs.initHighlightingOnLoad()</script>
<script>document.getElementById('main-nav-toggle').addEventListener('click',function(){var a=document.getElementById('header');a.classList.contains('mobile-on')?a.classList.remove('mobile-on'):a.classList.add('mobile-on')})</script>
</footer>
</div>
</body>
</html>