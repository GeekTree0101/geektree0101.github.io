<!doctype html><html dir=ltr lang=en data-theme class=html><head><title>Geektree0101
|
Vapor, 테스트 주도 개발을 해가면서 Slack slash command 만들기</title><meta charset=utf-8><meta name=generator content="Hugo 0.107.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="Geektree0101"><meta name=description content="왜 Vapor를 선택하게 되었는지, 어떠한 방식으로 TDD를 해가면서 간단한 Slack slash command API를 만들었는지에 대한 과정을 적어봤어요,."><link rel=stylesheet href=/scss/main.min.b2e0cb07595e3519ab1193bb421914e06c0e26b0cc561fef23b3c6131d4d2ffa.css integrity="sha256-suDLB1leNRmrEZO7QhkU4GwOJrDMVh/vI7PGEx1NL/o=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.b1c4e6a10bdbab01f33fff9d78816ee68cf9a9a731f07668afd546a79924cb80.css integrity="sha256-scTmoQvbqwHzP/+deIFu5oz5qacx8HZor9VGp5kky4A=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.423dee17c62f55fa733a4ee13e00d523dfce88cc4f4ab4549a24ba36bd9de681.css integrity="sha256-Qj3uF8YvVfpzOk7hPgDVI9/OiMxPSrRUmiS6Nr2d5oE=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.b7d54133b27e5b4de15245b8e143de3e8ed2d674c706137274cedc9953f31917.css integrity="sha256-t9VBM7J+W03hUkW44UPePo7S1nTHBhNydM7cmVPzGRc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=https://geektree0101.github.io/blog/blog7/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.738c0e3a493854876aeab9e2316fd43f1936aeeac4cc6b3e60bb26456dba72ad.js integrity="sha256-c4wOOkk4VIdq6rniMW/UPxk2rurEzGs+YLsmRW26cq0=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Vapor, 테스트 주도 개발을 해가면서 Slack slash command 만들기"><meta name=twitter:description content="왜 Vapor를 선택하게 되었는지, 어떠한 방식으로 TDD를 해가면서 간단한 Slack slash command API를 만들었는지에 대한 과정을 적어봤어요,."><meta property="og:title" content="Vapor, 테스트 주도 개발을 해가면서 Slack slash command 만들기"><meta property="og:description" content="왜 Vapor를 선택하게 되었는지, 어떠한 방식으로 TDD를 해가면서 간단한 Slack slash command API를 만들었는지에 대한 과정을 적어봤어요,."><meta property="og:type" content="article"><meta property="og:url" content="https://geektree0101.github.io/blog/blog7/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2020-11-13T22:28:49+00:00"><meta property="article:modified_time" content="2020-11-13T22:28:49+00:00"><meta property="og:site_name" content="Hyeonsu Ha"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"blog","name":"Vapor, 테스트 주도 개발을 해가면서 Slack slash command 만들기","headline":"Vapor, 테스트 주도 개발을 해가면서 Slack slash command 만들기","alternativeHeadline":"","description":"
      왜 Vapor를 선택하게 되었는지, 어떠한 방식으로 TDD를 해가면서 간단한 Slack slash command API를 만들었는지에 대한 과정을 적어봤어요,.


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/geektree0101.github.io\/blog\/blog7\/"},"author":{"@type":"Person","name":"Geektree0101"},"creator":{"@type":"Person","name":"Geektree0101"},"accountablePerson":{"@type":"Person","name":"Geektree0101"},"copyrightHolder":{"@type":"Person","name":"Geektree0101"},"copyrightYear":"2020","dateCreated":"2020-11-13T22:28:49.33Z","datePublished":"2020-11-13T22:28:49.33Z","dateModified":"2020-11-13T22:28:49.33Z","publisher":{"@type":"Organization","name":"Geektree0101","url":"https://geektree0101.github.io/","logo":{"@type":"ImageObject","url":"https:\/\/geektree0101.github.io\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/geektree0101.github.io\/blog\/blog7\/","wordCount":"912","genre":["Server"],"keywords":["vapor","swift","server"]}</script></head><body class="body theme--light"><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src="https://avatars.githubusercontent.com/u/19504988?v=4" alt="profile picture"><div class=sidebar__introduction-title><a href=/>Hyeonsu Ha</a></div><div class=sidebar__introduction-description><p>저는 Product Engineer이자 iOS App을 개발하고 있어요<br>제품설계, 가치전달, 협업문화에 대해 많은 관심을 가지고있어요.<br><br>I'm a Product Engineer & iOS software engineer.<br>I'm interested in product structure design, product value communication, and collaboration culture.<br><br>我是Product Engineer和iOS软件工程师。<br>我对产品结构设计、产品价值沟通、合作文化感兴趣。<br></p></div></div><ul class=sidebar__list><li class=sidebar__list-item><a href=https://www.linkedin.com/in/hyeonsu-ha-7ba02b112/ target=_blank rel=noopener aria-label=Linkedin title=Linkedin><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=h2s1880@gmail.com target=_blank rel=noopener aria-label=e-mail title=e-mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://github.com/GeekTree0101 target=_blank rel=noopener aria-label=github title=github><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://www.instagram.com/geektree0101/ target=_blank rel=noopener aria-label=instagram title=instagram><i class="fab fa-instagram fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
Geektree0101
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/ title>Index 0</a></li><li class=nav__list-item><a href=/gallery/ title>Index 1</a></li><li class=nav__list-item><a href=/about/ title>About</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Vapor, 테스트 주도 개발을 해가면서 Slack Slash Command 만들기</h1><h3 id=고린이golang-입문기시절>고린이(golang 입문기)시절</h3><p><img src=/images/blog/0__JHVa3o6dFCX83a0r.png alt></p><p>비록 iOS 앱을 개발하는 한낱의 모바일 개발자이지만, 지난 몇 달간 회사에 재직중인 고퍼(Gopher)분들로 부터 영감을 받아 <a href=https://echo.labstack.com/>Echo framework</a>기반으로 간단한 업무용 Slack slash command 로직은 만든적이 있었습니다.</p><p><img src=/images/blog/1__IN9z0xm3UCIOI3k73pwXYg.png alt></p><p>처음엔 코드를 작성하기 쉬웠지만 가면 갈수록 어렵게 느껴짐과 동시에 서버사이드 개발과 테스트가 미숙하다보니 구조는 오히려 망가져가고 정상적인 테스트 코드를 작성하지 못해서. 결국, 나는 망가진 코드를 직면하게 될 수 밖에 없었습니다. :[</p><p>제일 중요한건 혼자 이걸 유지보수 하다보니 외로움도 없잖아 있었습니다…</p><h3 id=구관이-명관>구관이 명관</h3><p>결국 제가 내린 결론은 처음부터 다시 새로 만드는 것!</p><p>새로만들기 전에 고려했던 포인트들은 다음과 같습니다.</p><ul><li>나와 함께 일하는 iOS 개발자들도 함께 만들어 나갈 수 있어야함</li><li>즐거운 테스트 주도 개발(의식의 흐름대로 코드를 작성하는 것을 피하고 싶음)</li><li>유연한 구조설계(특히, 추상화 가능한 언어를 사용하는 프레임워크!)</li></ul><p>위 3가지중 이번에 가장 중요한 포인트는 함께하는 부분에 집중했었고, 동료들은 Swift에 친숙하고 언어의 특성을 깊게 잘 알고 있는 상황이기 때문에, 결국 Swift Server Side Framework중 Vapor를 선택하게 되었습니다.</p><h3 id=framework-선택하기>Framework 선택하기</h3><p>Swift Server Side Framework는 대표적으로 크게 3가지가 있습니다.</p><ul><li>Kitura, <a href=https://github.com/Kitura/Kitura>https://github.com/Kitura/Kitura</a></li><li>Perfact, <a href=https://github.com/PerfectlySoft/Perfect>https://github.com/PerfectlySoft/Perfect</a></li><li>Vapor, <a href=https://github.com/vapor/vapor>https://github.com/vapor/vapor</a></li></ul><p>수 많은 Swift Server Side Framework중 굳이 Vapor를 선택한 이유는</p><p>Kitura는 거의 관리가 안되는게 실정이고 문제나 여러 이슈들이 쌓여있는게 현실입니다. 더군다나 3년전에 봤던 때와 비교했을 때 큰 변화나 발전이 없었습니다.</p><p>Perfact도 몇 년 동안 큰 변화는 없었지만, <a href=https://github.com/apple/swift-nio>Apple Swift-NIO</a>기반 작업한 <a href=https://github.com/PerfectlySoft/Perfect-NIO>레포지토리는 여전히 알파상태</a>에 있고 DX(Developer Experience)측면에서 아직까지 좋지 않은 느낌 없잖아 있었습니다.</p><p>마지막으로 남은게 Vapor인데, Vapor는 2020년 4월에 <a href=https://github.com/apple/swift-nio><strong>Swift-NIO</strong></a> 기반으로 구조 재설계 이후 꾸준한 활동성을 보여주고 있음과 동시에 Kitura나 Perfact와 비교했을 때 상대적으로 많은 장점과 좋은 DX를 제공하고 있어서 망설임 없이 Vapor를 채택하게 되었습니다.</p><h3 id=환경>환경</h3><ul><li>Vapor 4.0</li><li>Swift 5.2</li><li>SPM(Swift Package Manager) 기반 구성</li><li>돈쓰기 싫어서? Heroku에 Deploy</li></ul><h3 id=구조-설계>구조 설계</h3><p><img src=/images/blog/1__T4__FEemr1THb71parNwD4Q.png alt></p><p>Vapor framework자체에선 RouteCollection을 기반으로 한 MVC 구조를 가지고 있습니다. (Ruby on rails나 Django와 같은 다른 보편적인 프레임워크의 구조와 동일합니다.)</p><p>Controller(RouteCollection)는 중재자 역할을 하게 되지만, 비즈니스 로직이나 외부 서비스와의 연결등등이 많아지게 되면 <strong>Controller는 결국 Massive</strong>해지게 되고 테스트 하기도 쉽지않아서 수정이나 기능을 추가하다 보면 원치 않는 사이드 이펙트 버그가 생기고 프로덕트가 쉽게 무너지기 쉽습니다.</p><p>이를 피하기 위해서 나는 새로운 객체 두가지를 Controller로 부터 분리했습니다.</p><ul><li>Worker: 비즈니스 로직을 주로담당</li><li>Service: 외부 서비스 로직을 담당</li></ul><p>worker와 service는 각자 interface를 상속받아 구현을 합니다.</p><p>// worker</p><p>protocol CmdWorkerLogic { &mldr; }</p><p>struct CmdWorker: CmdWorkerLogic { &mldr; } // Production 용</p><p>struct CmdBetaWorker: CmdWorkerLogic { &mldr; } // Beta 용 (임의 작성)</p><p>// service</p><p>protocol GithubServiceLogic { &mldr; }</p><p>struct GithubService: GithubServiceLogic { &mldr; }</p><p><img src=/images/blog/1__oPlctJxFpCApQqRLlMpDog.png alt></p><p>그리고 controller에는 아래의 코드와 같이 작성합니다.</p><p>import Vapor</p><p>struct CmdController: RouteCollection, Then {</p><p>var worker: CmdWorkerLogic = CmdWorker()<br>var service: GithubServiceLogic = GithubService()</p><p>}</p><h3 id=테스트-설계>테스트 설계</h3><h4 id=test-double준비>Test Double 준비</h4><p>이후, Worker와 Service에 대한 Spy객체를 준비합니다.</p><p><em>WorkerSpy 객체 예시</em></p><p>import Vapor<br>@testable import App</p><p>final class CmdWorkerSpy: CmdWorkerLogic {</p><p>var pullReqeustCalled: Int = 0<br>var pullRequestStub: SlackMessage = .init()</p><p>func pullRequest(prs: [GithubPullRequest]) -> SlackMessage {</p><pre><code>self.pullRequestCalled += 1  
return self.pullRequestStub  
</code></pre><p>}</p><p>// ~~~ 생략 ~~~<br>}</p><p>ServiceSpy 객체 예시</p><p>import Vapor<br>@testable import App</p><p>final class GithubServiceSpy: GithubServiceLogic {</p><p>var getPullRequestsCalled: Int = 0<br>var getPullRequestsStub: EventLoopFuture&lt;[GithubPullRequest]>?</p><p>func getPullRequests(req: Request) -> EventLoopFuture&lt;[GithubPullRequest]> {</p><pre><code>self.getPullRequestCalled += 1  
return self.getPullRequestStub ??  
req.eventLoop.makeFailedFuture(Abort(.internalServerError))  
</code></pre><p>}</p><p>// ~~~ 생략 ~~~<br>}</p><ul><li>XXX Called 형태로 Integer를 선언한 이유는, 호출했는지 판단 할 수 있으며 호출 횟수까지 테스트 과정에서 식별하기 위함</li><li>XXX Stub 프로퍼티를 선언해 스터빙을 함으로써 다양한 테스트 시나리오 작성에 도움을 줍니다.</li><li>사실 Mockito나 별다른 Stubbing 서드파티 굳이 쓰지 않고 Test Double을 위와 같은 형태로 간단히 구현할 수 있습니다. (<a href=https://clean-swift.com/test-driven-development-using-clean-architecture-part-1/>Clean Swift TDD Part 1</a>)</li></ul><h4 id=unit-test작성>Unit Test 작성</h4><p>import Vapor<br>import XCTVapor<br>import Nimble</p><p>@testable import App</p><p>final class CmdControllerTests: XCTestCase {</p><p>var app: Application!</p><p>// sut: system under test<br>var sut: CmdController!</p><p>// test doubles<br>var githubService: GithubServiceSpy!<br>var worker: CmdWorkerSpy!</p><p>override func setUp() {</p><p>self.githubService = GithubServiceSpy()<br>self.worker = CmdWorkerSpy()<br>self.sut = CmdController().with {<br>$0.worker = self.worker<br>$0.service = self.githubService<br>}</p><p>self.app = Application(.testing).then {<br>try? configure($0)<br>try? $0.register(collection: self.sut)<br>}</p><p>}</p><p>override func tearDown() {</p><p>self.app.shutdown()<br>}</p><p>}</p><ul><li>setUp과 tearDown 구성</li><li>Nimble은 빠른 테스트 타이핑에 도움을 주기 위해서 import</li><li>with 나 then은 임의로 <a href=https://github.com/devxoul/Then>Then</a>에서 가져와서 사용했어요.</li></ul><p>그리고 아래의 코드와 같이 Worker와 Service Spy객체에 스터빙을 기반으로한 Test Code를 작성합니다.</p><p>// MARK: - Pull Request</p><p>extension CmdControllerTests {</p><p>func test_post_cmd_pull_request_success() throws {<br>// given<br>self.githubService.getPullRequestsStub = self.app.eventLoopGroup.future([GithubPullRequest()])</p><p>self.worker.pullRequestStub = SlackMessage()</p><p>// when<br>try self.app.test(.POST, &ldquo;/cmd&rdquo;, afterResponse: { res in<br>// then<br>expect(self.githubService.getPullRequestsCalled) == 1<br>expect(self.worker.pullRequestCalled) == 1<br>expect(res.status) == .ok<br>})<br>}</p><p>func test_post_cmd_pull_request_failed() throws {<br>// given<br>self.worker.isValidStub = true<br>self.worker.getTargetStub = .init(target: .pullRequest, query: nil)</p><pre><code>self.githubService.getPullRequestsStub = self.app.eventLoopGroup.future(error: Abort(.internalServerError)) 

// when      
try self.app.test(.POST, &quot;/cmd&quot;, afterResponse: { res in    
 // then        
 expect(self.githubService.getPullRequestsCalled) == 1       
 expect(self.worker.pullRequestCalled) == 0      
 expect(res.status) == .internalServerError      
})    
</code></pre><p>}</p><p>}</p><ul><li>given: 제안된 시나리오를 기반으로 worker나 service에 필요한 스터빙을 합니다.</li><li>when: 제안된 시나리오를 동작시킵니다.</li><li>then: when에 따른 결과값을 체크합니다.</li></ul><p>그리고 test를 돌려주면 해당 테스트는 실패하거나 부분적으로 성공했음을 알 수 있습니다. 즉, <strong>Red상태</strong>에 들어갑니다.</p><p><img src=/images/blog/1__ZjZnK3ZDJL03uTXKWpzZKQ.png alt></p><p>위와 같이 테스트를 작성하고 Worker와 Service의 실질적인 객체 내용을 구현을 합니다. <strong>Green 상태</strong> 즉, 테스트가 온전히 성공상태가 될 때까지 말입니다.</p><p>struct CmdWorker: CmdWorkerLogic {</p><p>func pullRequest(prs: [GithubPullRequest]) -> SlackMessage {<br>// 구현<br>}<br>}</p><p>struct GithubService: GithubServiceLogic { &mldr; 구현 &mldr; }</p><p>struct CmdController: RouteCollection { &mldr; 구현 &mldr; }</p><p>이후 Controller에 새로운 기능을 추가하거나, 비즈니스 로직 변경사항이 있으면 변경(<strong>Refactor</strong>) 을 통해서 다시 Red상태에 들어가게 되고 위와 같은 과정 반복을 통해 Green상태로 만들어가면서 안정적으로 프로덕트를 설계합니다.</p><p><img src=/images/blog/1__e8MNESnv9BdGlhNvwJDetg.png alt></p><h3 id=끝으로>끝으로</h3><p>Golang으로 지속가능한 개발을 하지 못한점은 아쉽긴하지만, 이번 프로젝트를 통해서 iOS팀 동료분들도 읽기 쉽고 함께 참여가능한 프로젝트를 만들었다는 부분에 대해서 큰 의미를 가지게 되었습니다.</p><p>최근에는 <a href=https://github.com/vapor/leaf>Leaf</a>기반으로 슬렉 Hook을 활용한 선택적 채널에 대한 전역적 공지사항 웹앱도 만들면서 아직까진 특별한 불편함 없이 잘 사용하고 있어서 마냥 행복합니다. :]</p><p>Swift-NIO와 Swift 그리고 Vapor의 무궁한 발전과 앞날을 기원하며 이 정도로 글 마무리하겠습니다.</p><p>읽어 주셔서 감사합니다.</p><p>더 궁금하신 내용이 있으시거나 수정할 내용이 보이신다면 언제든 편안하게 <a href=https://github.com/GeekTree0101/GeekTreeQnA>https://github.com/GeekTree0101/GeekTreeQnA</a> 에 이슈남겨주시면 감사하겠습니다.</p></div><div class=post__footer><span><a class=category href=/categories/server/>Server</a></span>
<span><a class=tag href=/tags/vapor/>vapor</a><a class=tag href=/tags/swift/>swift</a><a class=tag href=/tags/server/>server</a></span></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
Geektree0101
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></body></html>