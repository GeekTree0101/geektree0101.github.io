<!doctype html><html dir=ltr lang=en data-theme class=html><head><title>Geektree0101
|
Texture 2.7: RxSwift와 setNeedsLayout에 대한 고찰</title><meta charset=utf-8><meta name=generator content="Hugo 0.101.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="Geektree0101"><meta name=description content="Texture 2.7에서 많은 변화가 있었습니다. iOS 11 iPhoneX safeArea를 node 어디서든 적용할 수 있게 되었을 뿐만 아니라 전반적으로 퍼포먼스가 상향되었습니다."><link rel=stylesheet href=/scss/main.min.b2e0cb07595e3519ab1193bb421914e06c0e26b0cc561fef23b3c6131d4d2ffa.css integrity="sha256-suDLB1leNRmrEZO7QhkU4GwOJrDMVh/vI7PGEx1NL/o=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.b1c4e6a10bdbab01f33fff9d78816ee68cf9a9a731f07668afd546a79924cb80.css integrity="sha256-scTmoQvbqwHzP/+deIFu5oz5qacx8HZor9VGp5kky4A=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.423dee17c62f55fa733a4ee13e00d523dfce88cc4f4ab4549a24ba36bd9de681.css integrity="sha256-Qj3uF8YvVfpzOk7hPgDVI9/OiMxPSrRUmiS6Nr2d5oE=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.b7d54133b27e5b4de15245b8e143de3e8ed2d674c706137274cedc9953f31917.css integrity="sha256-t9VBM7J+W03hUkW44UPePo7S1nTHBhNydM7cmVPzGRc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=https://geektree0101.github.io/blog/2018-08-03_texture-2-7--rxswift--setneedslayout--------298609b85e1f/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.738c0e3a493854876aeab9e2316fd43f1936aeeac4cc6b3e60bb26456dba72ad.js integrity="sha256-c4wOOkk4VIdq6rniMW/UPxk2rurEzGs+YLsmRW26cq0=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Texture 2.7: RxSwift와 setNeedsLayout에 대한 고찰"><meta name=twitter:description content="Texture 2.7에서 많은 변화가 있었습니다. iOS 11 iPhoneX safeArea를 node 어디서든 적용할 수 있게 되었을 뿐만 아니라 전반적으로 퍼포먼스가 상향되었습니다."><meta property="og:title" content="Texture 2.7: RxSwift와 setNeedsLayout에 대한 고찰"><meta property="og:description" content="Texture 2.7에서 많은 변화가 있었습니다. iOS 11 iPhoneX safeArea를 node 어디서든 적용할 수 있게 되었을 뿐만 아니라 전반적으로 퍼포먼스가 상향되었습니다."><meta property="og:type" content="article"><meta property="og:url" content="https://geektree0101.github.io/blog/2018-08-03_texture-2-7--rxswift--setneedslayout--------298609b85e1f/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2018-08-03T17:05:52+00:00"><meta property="article:modified_time" content="2018-08-03T17:05:52+00:00"><meta property="og:site_name" content="Hyeonsu Ha"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"blog","name":"Texture 2.7: RxSwift와 setNeedsLayout에 대한 고찰","headline":"Texture 2.7: RxSwift와 setNeedsLayout에 대한 고찰","alternativeHeadline":"","description":"
      Texture 2.7에서 많은 변화가 있었습니다. iOS 11 iPhoneX safeArea를 node 어디서든 적용할 수 있게 되었을 뿐만 아니라 전반적으로 퍼포먼스가 상향되었습니다.


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/geektree0101.github.io\/blog\/2018-08-03_texture-2-7--rxswift--setneedslayout--------298609b85e1f\/"},"author":{"@type":"Person","name":"Geektree0101"},"creator":{"@type":"Person","name":"Geektree0101"},"accountablePerson":{"@type":"Person","name":"Geektree0101"},"copyrightHolder":{"@type":"Person","name":"Geektree0101"},"copyrightYear":"2018","dateCreated":"2018-08-03T17:05:52.10Z","datePublished":"2018-08-03T17:05:52.10Z","dateModified":"2018-08-03T17:05:52.10Z","publisher":{"@type":"Organization","name":"Geektree0101","url":"https://geektree0101.github.io/","logo":{"@type":"ImageObject","url":"https:\/\/geektree0101.github.io\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/geektree0101.github.io\/blog\/2018-08-03_texture-2-7--rxswift--setneedslayout--------298609b85e1f\/","wordCount":"679","genre":["iOS"],"keywords":["ios","texture","bug"]}</script></head><body class="body theme--light"><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src="https://avatars.githubusercontent.com/u/19504988?v=4" alt="profile picture"><div class=sidebar__introduction-title><a href=/>Hyeonsu Ha</a></div><div class=sidebar__introduction-description><p>엔지니어링의 근본은 문제해결이며<br>저에게 있어서 문제에 대한 해결과 해결에 따른 새로운 문제는 놀이이자 즐거움입니다.<br>문제해결을 위한 빠른 프로토 타이핑과 제품 실현화를 즐기며,<br>이 과정에서 함께하는 동료들과 지속적으로 성장가능한 협업 문화를 추구합니다.<br><br>#Geektree0101 #David #iOS #Gopher #Karrot #당근마켓 #Vingle #MIRO<br></p></div></div><ul class=sidebar__list><li class=sidebar__list-item><a href=https://www.linkedin.com/in/hyeonsu-ha-7ba02b112/ target=_blank rel=noopener aria-label=Linkedin title=Linkedin><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=h2s1880@gmail.com target=_blank rel=noopener aria-label=e-mail title=e-mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://github.com/GeekTree0101 target=_blank rel=noopener aria-label=github title=github><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://www.instagram.com/geektree0101/ target=_blank rel=noopener aria-label=instagram title=instagram><i class="fab fa-instagram fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
Geektree0101
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.602bd2014468bd348112e2aa24f595c530d257a4ed6c335d7baaa6ac9a7ca6fb.js integrity="sha256-YCvSAURovTSBEuKqJPWVxTDSV6TtbDNde6qmrJp8pvs=" crossorigin=anonymous></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/ title>Index 0</a></li><li class=nav__list-item><a href=/about/ title>About</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Texture 2.7: RxSwift와 SetNeedsLayout에 대한 고찰</h1><p><img src=/images/blog/1__T8CAgDZ__c9F6E0DiFQYW6Q.png alt></p><p>Texture 2.7에서 많은 변화가 있었습니다. iOS 11 iPhoneX safeArea를 node 어디서든 적용할 수 있게 되었을 뿐만 아니라 전반적으로 퍼포먼스가 상향되었습니다.</p><p>하지만</p><p>Texture 2.6에서 2.7로 마이그레이션 후 프로덕트 테스트를 한 결과 치명적인 문제점을 발견하였는데 바로 아래 이슈입니다.</p><p><a href=https://github.com/TextureGroup/Texture/issues/977 title=https://github.com/TextureGroup/Texture/issues/977><strong>[ASDisplayNode] setNeedsLayout doesn&rsquo;t work only Texture 2.7 · Issue #977 · TextureGroup/Texture</strong><br>_similar issue In my case, I forced setNeedLayout after textNode attributedText value with a few sec delay…_github.com</a><a href=https://github.com/TextureGroup/Texture/issues/977></a></p><p><img src=/images/blog/0__4RGACF948xouJsbY.png alt></p><p>아무리 setNeedsLayout를 호출해도 layoutSpecThatFits: 에서 내려오는 constrainedSize (ASSizeRange)의 max과 min값이 변하지 않고 같은 값으로 계속 유지된다는 점이다.</p><p>그래서 해당 부분에 대해서면 집중적으로 내부 동작을 분석한 결과를 보여드리고자 합니다.</p><p>우선!</p><p>Node가 didLoad 되기 전/후로 나눠서 볼 수가 있습니다.</p><p>만약 init시점에서 어떤 Rx를 subscribe하고 onNext에서 setNeedsLayout을 호출한다고 가정합시다.</p><p>그러면 아래의 코드가 동작을 하게 됩니다.</p><p><img src=/images/blog/1__TJ5bncYpUdB8NOjhX5RFIQ.png alt></p><p>우선 subscribe onNext 동작시점이 Node가 didLoad되기 전/후 어느 한쪽을 확실히 보장하지 못합니다.</p><p>그러므로 didLoad 이후라면 layoutIfNeeded method가 호출 될 것이고, didLoad 전이면 __layout(내부 layout api)가 호출됩니다.</p><p>결국 Texture 2.7에서 __layout method에서 threadSafeBounds가 변해야지 그렇지 않으면 _u_measureNodeWithBoundsIfNecessary에서 원치않는 measurement 결과값이 나와 constrainedSize가 변하지 않는걸 발견 할 수가 있습니다.</p><p><img src=/images/blog/1__LGr0__wh0Dguyr__OH__aQO2Q.png alt>
<img src=/images/blog/1__dwJ__sS0H6gnT__IUzawWfeg.png alt></p><p>하지만 친절하게도 다음과 같은 Commit을 발견할 수가 있었다.</p><p><img src=/images/blog/1__c__2S__JiZVY__fVQvcivOJkw.png alt></p><p>didEnterPreloadState에서 automaticallyManagesSubnodes가 true일때 layoutIfNeeded를 호출 한다는 점입니다.</p><p>위의 주석을 해석하자면 다음과 같습니다.</p><blockquote><p>해당 노드에 ASM(automaticallyManagesSubnodes)이 활성화되어 있으며, 아직 Visible상태가 아님과 동시에 적용 가능한 보류중인 레이아웃이 있는 경우, 해당 레이아웃을 적용하도록 레이아웃 패스를 강제 실행합니다.</p></blockquote><p>하지만 필자의 눈에는 이 부분이 좀 거슬렸습니다.</p><blockquote><p>// — If it doesn’t have a calculated or pending layout that fits its current bounds, a measurement pass will occur</p></blockquote><blockquote><p>// (see -__layout and -_u_measureNodeWithBoundsIfNecessary:). This scenario is uncommon,</p></blockquote><blockquote><p>// and running a measurement pass here is a fine trade-off because preloading any time after this point would be late.</p></blockquote><p>즉, 현재 경계에 맞는 계산된거 또는 Pending된 레이아웃이없는 경우 <strong>측정 패스가 발생</strong>하며 이 같은 현상은 드문 경우라고 되어있다. 게다가 __ layout 및 -_u_measureNodeWithBoundsIfNecessary 참고해라고 하니…</p><p>결국 node가 didLoad되기 전 시점에서 __layout이 호출되는것은 가급적이면 피하던가 아니면 기존 디스플레이에 대해 이전에 measure되고 캐쉬 된 레이아웃을 무효로 할 수 있는 코드가 필요하다는 점입니다.</p><p>우선 didLoad이전 시점에서 setNeedsLayout을 호출하는것을 피하는 방향으로 작업을 해봤습니다.</p><p><img src=/images/blog/1__tcwmE54t__u4pmeBVr7T5__A.png alt></p><p>RxCocoa에서 제공하는 methoInvoked(메서드의 동작 이후의 이벤트를 획득)를 이용하여 node가 didLoad되지 않았을 때 해당 Wrapper를 이용해서 didLoad를 subscribe하여 onNext시 setNeedsLayout을 호출하는 기법으로 시도하였습니다.</p><p><img src=/images/blog/1__8r__vAfXeGBiNSTaSUyFoTg.png alt></p><p>물론 앞서 언급된 UI Layout measurement 측면에선 문제가 없었으나, 싱글뷰가 아닌 리스트형태의 뷰에서 InterfaceStatus와 사용자 스크롤에 대한 반응성이 나빠지는 현상을 발견할 수가 있었습니다.</p><p>이러면 Texture를 써봐야 의미가 없습니다.</p><p>그렇다면 마지막 대안인 <strong>기존 디스플레이에 대해 이전에 measure되고 캐쉬 된 레이아웃을 무효로 할 수 있는 코드</strong> 가 필요하다는게 확실해졌다고 할 수 있겠습니다.</p><p>친절하게도 Texture에서는 그러한 필요한 API를 제공해주는데 바로</p><p><strong>invalidateCalculatedLayout 이라는 메서드를 제공해줍니다.</strong></p><p>해당 메서드에 주석이 달려있는데 다음과 같습니다.</p><blockquote><p>/**</p></blockquote><blockquote><p>* @abstract Invalidate previously measured and cached layout.</p></blockquote><blockquote><p>*</p></blockquote><blockquote><p>* @discussion Subclasses should call this method to invalidate the previously measured and cached layout for the display</p></blockquote><blockquote><p>* node, when the contents of the node change in such a way as to require measuring it again.</p></blockquote><blockquote><p>*/</p></blockquote><p>해석하자면 Node의 내용이 다시 요구할 수있는 방식으로 변경 될 때. 해당 메서드를 호출하여 디스플레이에 대해서 이전에 측정되고 캐쉬된 레이아웃을 무효로 할 필요가 있을 때 사용해라고 명시적으로 나와있습니다. 즉, <strong>측정 및 캐시 된 레이아웃을 무효화한다는 것입니다.</strong></p><p>또한 앞서 말했던 didEnterPreloadState의 주석내용과 같이 <strong>layoutIfNeeds</strong>를 같이 사용할 것입니다. 이거 또한 주석을 보면 다음과 같습니다.</p><p>View나 Layer의 load상태의 여부에 관계없이 편리하게 사용할 수 있다고 명시되어 있으며, Background Thread에서 안전하게 호출 할 수 있다고 합니다.</p><p>그렇다면 layoutIfNeeds호출전에 현재 레이아웃을 무효화하고 다음 업데이트주기 동안 레이아웃 업데이트를 Trigger를 하기위해서 <strong>setNeedsLayout</strong>까지 응용하자면 다음과 같이 코드를 작성 할 수가 있습니다.</p><p><img src=/images/blog/1__E8LNaa1MmMi2__Cq__qvbHgQ.png alt></p><p>다음 업데이트주기 동안 레이아웃 업데이트에 대한 트리거와 동시에 View나 Layer의 load상태의 여부에 관계없이 레이아웃 업데이트가 보류중인 경우 하위 뷰를 즉시 레이아웃 업데이트하며 동시에 측정 및 캐시 된 레이아웃을 무효화함으로써 constrainedSize가 고정값으로 유지되는 현상을 막는 방법입니다.</p><p>Node에서의 setNeedsLayout과 layoutIfNeeds Thread에 대해서 안정성을 가지고 있기 때문에 퍼포먼스상 문제는 없으며 동시에 사용자 스크롤 반응성 또한 기대값만큼 보여주는 것을 확인 할 수가 있었습니다.</p><blockquote><p>가장 이상적인건 init시점에서 동기적으로 각 서브노드들의 데이터를 업데이트 해주고 그 이후에 발생하는 이벤트를 비동기적으로 해당하는 노드에 대해서 데이터를 업데이트 해주는것이 였으나 이러한 방법은 <a href=https://www.slideshare.net/ChiwonSong/20180721-code-defragment-106434267>코드 응집도</a>(곰튀김님 자료참고)에 좋지 않으며 MVC가 아닌 MVVM 패턴에선 사실상 좋지 않은 방법이라 생각합니다. (물론 주관적인 견해입니다.)</p></blockquote><p>이번 게시글에 대한 내용은 여기까지입니다.</p><p>그리고 위의 내용은 아래의 Repo를 통해서 확인 하실 수가 있습니다.</p><p><a href=https://github.com/GeekTree0101/RxCocoa-Texture title=https://github.com/GeekTree0101/RxCocoa-Texture><strong>GeekTree0101/RxCocoa-Texture</strong><br>_RxCocoa-Texture - RxCocoa Extension Library for Texture._github.com</a><a href=https://github.com/GeekTree0101/RxCocoa-Texture></a></p><p>시작한지 얼마 안됬지만</p><h3 id=컨트리뷰터는-언제나환영합니다>컨트리뷰터는 언제나 환영합니다!!!</h3></div><div class=post__footer><span><a class=category href=/categories/ios/>iOS</a></span>
<span><a class=tag href=/tags/ios/>ios</a><a class=tag href=/tags/texture/>texture</a><a class=tag href=/tags/bug/>bug</a></span></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
Geektree0101
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.602bd2014468bd348112e2aa24f595c530d257a4ed6c335d7baaa6ac9a7ca6fb.js integrity="sha256-YCvSAURovTSBEuKqJPWVxTDSV6TtbDNde6qmrJp8pvs=" crossorigin=anonymous></script></body></html>